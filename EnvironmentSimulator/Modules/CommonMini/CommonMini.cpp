/*
 * esmini - Environment Simulator Minimalistic
 * https://github.com/esmini/esmini
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Copyright (c) partners of Simulation Scenarios
 * https://sites.google.com/view/simulationscenarios
 */

#include "logger.hpp"

#include "Config.hpp"
#include "ConfigParser.hpp"

#include <stdarg.h>
#include <stdio.h>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <vector>
#include <sstream>
#include <locale>
#include <array>
#include <regex>
#include <chrono>
#include <iomanip>
#include <string>

// UDP network includes
#ifndef _WIN32
/* Assume that any non-Windows platform uses POSIX-style sockets instead. */
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>  /* Needed for getaddrinfo() and freeaddrinfo() */
#include <unistd.h> /* Needed for close() */
#else
#include <winsock2.h>
#include <Ws2tcpip.h>
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
#include <timezoneapi.h>
#elif defined(__APPLE__)
#include <mach-o/dyld.h>
#include <dlfcn.h>
#elif defined(__linux__)
#include <dlfcn.h>
#include <unistd.h>
#include <limits.h>
#elif defined(__EMSCRIPTEN__)
// WASM/Emscripten - no dynamic library support needed
#endif

#if __has_include(<filesystem>)
#include <filesystem>
namespace fs = std::filesystem;
#elif __has_include(<experimental/filesystem>)
#include <experimental/filesystem>
namespace fs = std::experimental::filesystem;
#else
#error "Missing <filesystem> header"
#endif

// #define DEBUG_TRACE

// These variables are autogenerated and compiled
// into the library by the version.cmake script
extern const char* ESMINI_GIT_TAG;
extern const char* ESMINI_GIT_REV;
extern const char* ESMINI_GIT_BRANCH;
extern const char* ESMINI_BUILD_VERSION;

static SE_SystemTime systemTime_;
static const int     max_csv_entry_length = 1024;
static id_t          global_id            = 0;

const char* esmini_git_tag(void)
{
    return ESMINI_GIT_TAG;
}

const char* esmini_git_rev(void)
{
    return ESMINI_GIT_REV;
}

const char* esmini_git_branch(void)
{
    return ESMINI_GIT_BRANCH;
}

const char* esmini_build_version(void)
{
    return ESMINI_BUILD_VERSION;
}

id_t GetNewGlobalId()
{
    id_t returnvalue = global_id;
    global_id++;
    return returnvalue;
}

void ResetGlobalIdCounter()
{
    global_id = 0;
}

std::map<int, std::string> ParseModelIds()
{
    std::map<int, std::string> entity_model_map_;

    const std::string filename = "model_ids.txt";
    bool              found    = false;
    std::ifstream infile(LocateFile(filename, {DirNameOf(SE_Env::Inst().GetEXEFilePath()) + "/../resources", "resources"}, "Model ID file", found));
    if (infile.is_open())
    {
        int         id;
        std::string model3d;
        while (infile >> id >> model3d)
        {
            entity_model_map_[id] = model3d;
        }
    }
    infile.close();

    return entity_model_map_;
}

std::string ControlDomainMask2Str(unsigned int domain_mask)
{
    std::string str;

    if (domain_mask != static_cast<unsigned int>(ControlDomainMasks::DOMAIN_MASK_NONE))
    {
        if (domain_mask & static_cast<unsigned int>(ControlDomainMasks::DOMAIN_MASK_LAT))
        {
            str += "Lateral";
        }

        if (domain_mask & static_cast<unsigned int>(ControlDomainMasks::DOMAIN_MASK_LONG))
        {
            if (!str.empty())
            {
                str += " & ";
            }
            str += "Longitudinal";
        }

        if (domain_mask & static_cast<unsigned int>(ControlDomainMasks::DOMAIN_MASK_LIGHT))
        {
            if (!str.empty())
            {
                str += " & ";
            }
            str += "lighting";
        }

        if (domain_mask & static_cast<unsigned int>(ControlDomainMasks::DOMAIN_MASK_ANIM))
        {
            if (!str.empty())
            {
                str += " & ";
            }
            str += "Animation";
        }
    }
    else
    {
        str = "None";
    }

    return str;
}

ControlDomainMasks ControlDomain2DomainMask(ControlDomains domain)
{
    switch (domain)
    {
        case ControlDomains::DOMAIN_LONG:
            return ControlDomainMasks::DOMAIN_MASK_LONG;
        case ControlDomains::DOMAIN_LAT:
            return ControlDomainMasks::DOMAIN_MASK_LAT;
        case ControlDomains::DOMAIN_LIGHT:
            return ControlDomainMasks::DOMAIN_MASK_LIGHT;
        case ControlDomains::DOMAIN_ANIM:
            return ControlDomainMasks::DOMAIN_MASK_ANIM;
        default:
            break;
    }

    return ControlDomainMasks::DOMAIN_MASK_NONE;
}

std::string ControlDomain2Str(ControlDomains domain)
{
    if (domain != ControlDomains::COUNT)
    {
        return ControlDomainMask2Str(static_cast<unsigned int>(ControlDomain2DomainMask(domain)));
    }

    return "Undefined";
}

std::string CombineDirectoryPathAndFilepath(std::string dir_path, std::string file_path)
{
    std::string path = file_path;

    if (!file_path.empty() && file_path[0] != '/' && file_path[0] != '\\' && file_path[1] != ':')
    {
        // Relative path. Make sure it starts with ".." or "./"
        if (path[0] != '.')
        {
            path.insert(0, "./");
        }
        if (dir_path != "")
        {
            // Combine with directory path
            path.insert(0, dir_path + '/');
        }
    }

    return path;
}

std::string LocateFile(const std::string& file_path, const std::vector<std::string>& dirs, const std::string& label, bool& found, bool log_not_found)
{
    found = false;
    std::vector<std::string> file_name_candidates;
    std::string              filename = FileNameOf(file_path);

    // First add given file path and filename
    file_name_candidates.push_back(file_path);
    if (filename != file_path)
    {
        file_name_candidates.push_back(filename);
    }

    for (auto& env_path : SE_Env::Inst().GetPaths())
    {
        file_name_candidates.push_back(CombineDirectoryPathAndFilepath(env_path, file_path));
        if (filename != file_path)
        {
            file_name_candidates.push_back(CombineDirectoryPathAndFilepath(env_path, filename));
        }
    }

    for (auto& dir : dirs)
    {
        file_name_candidates.push_back(CombineDirectoryPathAndFilepath(dir, file_path));
        if (filename != file_path)
        {
            file_name_candidates.push_back(CombineDirectoryPathAndFilepath(dir, filename));
        }
    }

    for (auto& candidate : file_name_candidates)
    {
        if (!fs::exists(candidate))
        {
            continue;  // file not found, try next candidate
        }

        std::string canonical_path = LexicallyNormalizePath(candidate);

        found = true;

        if (canonical_path == file_path)
        {
            LOG_DEBUG("{} {} located", label, canonical_path);
        }
        else
        {
            LOG_DEBUG("{} {} located at {}", label, filename, canonical_path);
        }

        // found file, return the filepath regardless of success of loading
        return canonical_path;
    }

    if (log_not_found)
    {
        LOG_INFO("{} search paths attempted for file {}:", label, filename);
        for (auto& candidate : file_name_candidates)
        {
            LOG_INFO("  {}", candidate);
        }

        // fallback to given path
        LOG_WARN("{} {} not located, using specified file path", label, file_path);
    }

    return file_path;
}

double GetAngleOfVector(double x, double y)
{
    double angle;
    if (abs(x) < SMALL_NUMBER)
    {
        if (abs(y) < SMALL_NUMBER)
        {
            return 0.0;  // undefined
        }
        x = SIGN(x) * SMALL_NUMBER;
    }
    angle = atan2(y, x);
    if (angle < 0.0)
    {
        angle += 2 * M_PI;
    }
    return angle;
}

double GetAbsAngleDifference(double angle1, double angle2)
{
    double diff = fmod(angle1 - angle2, 2 * M_PI);

    if (diff < 0)
    {
        diff += 2 * M_PI;
    }

    if (diff > M_PI)
    {
        diff = 2 * M_PI - diff;
    }

    return GetAngleInInterval2PI(diff);
}

double GetAngleDifference(double angle1, double angle2)
{
    double diff = fmod(angle1 - angle2, 2 * M_PI);

    if (diff < -M_PI)
    {
        diff += 2 * M_PI;
    }
    else if (diff > M_PI)
    {
        diff -= 2 * M_PI;
    }

    return diff;
}

bool IsAngleForward(double teta)
{
    double teta_norm = GetAngleInInterval2PI(teta);
    return !(teta_norm > M_PI_2 && teta_norm < 3 * M_PI_2);
}

double GetAngleSum(double angle1, double angle2)
{
    return GetAngleInInterval2PI(angle1 + angle2);
}

double GetAngleInInterval2PI(double angle)
{
    double angle2 = fmod(angle, 2 * M_PI);

    if (angle2 < 0)
    {
        angle2 += 2 * M_PI;
    }
    else if (std::signbit(angle2))
    {
        angle2 = 0;
    }

    return angle2;
}

double GetAngleInIntervalMinusPIPlusPI(double angle)
{
    double angle2 = fmod(angle, 2 * M_PI);

    if (angle2 < -M_PI)
    {
        angle2 += 2 * M_PI;
    }
    else if (angle2 > M_PI)
    {
        angle2 -= 2 * M_PI;
    }

    return angle2;
}

int GetIntersectionOfTwoLineSegments(double  ax1,
                                     double  ay1,
                                     double  ax2,
                                     double  ay2,
                                     double  bx1,
                                     double  by1,
                                     double  bx2,
                                     double  by2,
                                     double& x3,
                                     double& y3)
{
    // Inspiration: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection

    double t_demonitator = (ax1 - ax2) * (by1 - by2) - (ay1 - ay2) * (bx1 - bx2);

    if (fabs(t_demonitator) < SMALL_NUMBER)
    {
        return -1;
    }

    double t = ((ax1 - bx1) * (by1 - by2) - (ay1 - by1) * (bx1 - bx2)) / t_demonitator;

    x3 = ax1 + t * (ax2 - ax1);
    y3 = ay1 + t * (ay2 - ay1);

    return 0;
}

int GetIntersectionsOfLineAndCircle(const double (&p0)[2],
                                    const double (&p1)[2],
                                    const double (&cc)[2],
                                    const double cr,
                                    double (&i0)[2],
                                    double (&i1)[2])
{
    int num_intersections = 0;

    // Use the quadratic formula to find intersections
    double dx           = p1[0] - p0[0];
    double dy           = p1[1] - p0[1];
    double A            = dx * dx + dy * dy;
    double B            = 2 * (dx * (p0[0] - cc[0]) + dy * (p0[1] - cc[1]));
    double C            = (p0[0] - cc[0]) * (p0[0] - cc[0]) + (p0[1] - cc[1]) * (p0[1] - cc[1]) - cr * cr;
    double discriminant = B * B - 4 * A * C;

    if (discriminant < -SMALL_NUMBER)
    {
        // No intersection
        return 0;
    }
    else if (NEAR_NUMBERS(discriminant, 0))
    {
        // One intersection
        double t          = -B / (2 * A);
        i0[0]             = p0[0] + t * dx;
        i0[1]             = p0[1] + t * dy;
        num_intersections = 1;
    }
    else
    {
        // Two intersections
        double sqrt_discriminant = sqrt(discriminant);
        double t1                = (-B + sqrt_discriminant) / (2 * A);
        double t2                = (-B - sqrt_discriminant) / (2 * A);
        i0[0]                    = p0[0] + t1 * dx;
        i0[1]                    = p0[1] + t1 * dy;
        i1[0]                    = p0[0] + t2 * dx;
        i1[1]                    = p0[1] + t2 * dy;
        num_intersections        = 2;
    }

    return num_intersections;
}

bool PointInBetweenVectorEndpoints(double x3, double y3, double x1, double y1, double x2, double y2, double& sNorm)
{
    bool inside;

    if (fabs(y2 - y1) < SMALL_NUMBER && fabs(x2 - x1) < SMALL_NUMBER)
    {
        // same point
        sNorm  = 0.0;
        inside = true;
    }
    else if (fabs(x2 - x1) < fabs(y2 - y1))  // Line is steep (more vertical than horizontal
    {
        sNorm = (y3 - y1) / (y2 - y1);
        if (y2 > y1)  // ascending
        {
            inside = !(y3 < y1 || y3 > y2);
        }
        else
        {
            inside = !(y3 > y1 || y3 < y2);
        }
    }
    else
    {
        sNorm = (x3 - x1) / (x2 - x1);
        if (x2 > x1)  // forward
        {
            inside = !(x3 < x1 || x3 > x2);
        }
        else
        {
            inside = !(x3 > x1 || x3 < x2);
        }
    }
    if (!inside)
    {
        if (sNorm < 0)
        {
            sNorm = -PointDistance2D(x3, y3, x1, y1);
        }
        else
        {
            sNorm = PointDistance2D(x3, y3, x2, y2);
        }
    }
    return inside;
}

double DistanceFromPointToEdge2D(double x3, double y3, double x1, double y1, double x2, double y2, double* x, double* y)
{
    double px       = 0;
    double py       = 0;
    double distance = 0;
    double sNorm    = 0;

    // First project point on edge
    ProjectPointOnLine2D(x3, y3, x1, y1, x2, y2, px, py);
    distance = PointDistance2D(x3, y3, px, py);

    if (PointInBetweenVectorEndpoints(px, py, x1, y1, x2, y2, sNorm))
    {
        // Point within edge interior
        if (x)
            *x = px;
        if (y)
            *y = py;
    }
    else if (sNorm < 0)
    {
        // measure to first endpoint
        distance = PointDistance2D(x3, y3, x1, y1);
        if (x)
            *x = x1;
        if (y)
            *y = y1;
    }
    else
    {
        // measure to other (2:nd) endpoint
        distance = PointDistance2D(x3, y3, x2, y2);
        if (x)
            *x = x2;
        if (y)
            *y = y2;
    }

    return distance;
}

double DistanceFromPointToLine2D(double x3, double y3, double x1, double y1, double x2, double y2, double* x, double* y)
{
    double distance = 0;
    double xp = 0.0, yp = 0.0;

    // project point on edge, and measure distance to that point
    if (x == nullptr)
        x = &xp;
    if (y == nullptr)
        y = &yp;
    ProjectPointOnLine2D(x3, y3, x1, y1, x2, y2, *x, *y);
    distance = PointDistance2D(x3, y3, *x, *y);

    return distance;
}

double DistanceFromPointToLine2DWithAngle(double x3, double y3, double x1, double y1, double angle)
{
    return (x3 - x1) * std::sin(angle) - (y3 - y1) * std::cos(angle);
}

int PointSideOfVec(double px, double py, double vx1, double vy1, double vx2, double vy2)
{
    // Use cross product
    return SIGN(GetCrossProduct2D((vx2 - vx1), (px - vx1), (vy2 - vy1), (py - vy1)));
}

double PointDistance2D(double x0, double y0, double x1, double y1)
{
    return sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
}

double PointToLineDistance2DSigned(double px, double py, double lx0, double ly0, double lx1, double ly1)
{
    double l0x      = lx1 - lx0;
    double l0y      = ly1 - ly0;
    double cp       = GetCrossProduct2D(lx1 - lx0, ly1 - ly0, px - lx0, py - ly0);
    double l0Length = sqrt(l0x * l0x + l0y * l0y);
    return cp / l0Length;
}

double PointSquareDistance2D(double x0, double y0, double x1, double y1)
{
    return (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
}

double PointHeadingDistance2D(double x0, double y0, double h, double x1, double y1)
{
    (void)h;
    return (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
}

void ProjectPointOnLine2D(double x, double y, double vx1, double vy1, double vx2, double vy2, double& px, double& py)
{
    // Project the given point on the straight line between geometry end points
    // https://stackoverflow.com/questions/1811549/perpendicular-on-a-line-from-a-given-point

    double dx = vx2 - vx1;
    double dy = vy2 - vy1;

    if (fabs(dx) < SMALL_NUMBER && fabs(dy) < SMALL_NUMBER)
    {
        // Line too small - projection not possible, copy first point position
        px = vx1;
        py = vy1;
    }
    else
    {
        double k = (dy * (x - vx1) - dx * (y - vy1)) / (dy * dy + dx * dx);
        px       = x - k * dy;
        py       = y + k * dx;
    }
}

void ProjectPointOnVector2D(double x0, double y0, double x1, double y1, double& px, double& py)
{
    double square_length = GetDotProduct2D(x1, y1, x1, y1);

    if (square_length > SMALL_NUMBER)
    {
        double scalar_proj = GetDotProduct2D(x0, y0, x1, y1) / square_length;
        px                 = x1 * scalar_proj;
        py                 = y1 * scalar_proj;
    }
    else
    {
        px = 0.0;
        py = 0.0;
    }
}

double ProjectPointOnVector2DSignedLength(double x0, double y0, double x1, double y1, double& px, double& py)
{
    ProjectPointOnVector2D(x0, y0, x1, y1, px, py);

    double length = GetLengthOfVector2D(px, py);
    if (SIGN(px) != SIGN(x1) || SIGN(py) != SIGN(y1))
    {
        length *= -1;  // projected point in opposite direction
    }

    return length;
}

bool IsPointWithinSectorBetweenTwoLines(SE_Vector p, SE_Vector l0p0, SE_Vector l0p1, SE_Vector l1p0, SE_Vector l1p1, double& sNorm)
{
    // If point is on the right side of first normal and to the left side of the second normal, then it's in between else not
    double d0 = (p - l0p0).Cross(l0p1 - l0p0);
    double d1 = (p - l1p0).Cross(l1p1 - l1p0);

    double x = 0.0, y = 0.0;

    // Find factor between 0,1 how close the point is the first (0) vs second point (1)
    double dist0 = DistanceFromPointToLine2D(p.x(), p.y(), l0p0.x(), l0p0.y(), l0p1.x(), l0p1.y(), &x, &y);
    double dist1 = DistanceFromPointToLine2D(p.x(), p.y(), l1p0.x(), l1p0.y(), l1p1.x(), l1p1.y(), &x, &y);

    sNorm = dist0 / MAX(SMALL_NUMBER, dist0 + dist1);

    if (d0 > 0 && d1 < 0)
    {
        return true;
    }
    else if (d0 < 0 && d1 > 0)
    {
        sNorm = -sNorm;
        return true;
    }
    else
    {
        if (dist0 < dist1)
        {
            sNorm = -dist0;
        }
        else
        {
            sNorm = dist1;
        }

        return false;
    }
}

double GetLengthOfLine2D(double x1, double y1, double x2, double y2)
{
    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}

double GetLengthOfVector2D(double x, double y)
{
    return sqrt(x * x + y * y);
}

double GetLengthOfVector3D(double x, double y, double z)
{
    return sqrt(x * x + y * y + z * z);
}

void RotateVec2D(double x, double y, double angle, double& xr, double& yr)
{
    xr = x * cos(angle) - y * sin(angle);
    yr = x * sin(angle) + y * cos(angle);
}

void Global2LocalCoordinates(double  xTargetGlobal,
                             double  yTargetGlobal,
                             double  xHostGlobal,
                             double  yHostGlobal,
                             double  angleHost,
                             double& targetXforHost,
                             double& targetYforHost)
{
    double relativeX = xTargetGlobal - xHostGlobal;
    double relativeY = yTargetGlobal - yHostGlobal;
    targetXforHost   = relativeX * cos(angleHost) - relativeY * sin(angleHost);
    targetYforHost   = relativeX * sin(angleHost) + relativeY * cos(angleHost);
}

void Local2GlobalCoordinates(double& xTargetGlobal,
                             double& yTargetGlobal,
                             double  xHostGlobal,
                             double  yHostGlobal,
                             double  thetaGlobal,
                             double  targetXforHost,
                             double  targetYforHost)
{
    xTargetGlobal = targetXforHost * cos(-thetaGlobal) + targetYforHost * sin(-thetaGlobal) + xHostGlobal;

    yTargetGlobal = targetYforHost * cos(-thetaGlobal) - targetXforHost * sin(-thetaGlobal) + yHostGlobal;
}

void SwapByteOrder(unsigned char* buf, int data_type_size, int buf_size)
{
    unsigned char* ptr = buf;
    unsigned char  tmp;

    if (data_type_size < 2)
    {
        // No need to swap for one byte data types
        return;
    }

    for (int i = 0; i < buf_size / data_type_size; i++)
    {
        for (int j = 0; j < data_type_size / 2; j++)
        {
            tmp                         = ptr[j];
            ptr[j]                      = ptr[data_type_size - j - 1];
            ptr[data_type_size - j - 1] = tmp;
        }
        ptr += data_type_size;
    }
}

bool IsNumber(const std::string& str, int max_digits)
{
    if (str.empty())
    {
        return false;
    }

    int counter = 0;
    for (auto& c : str)
    {
        counter++;
        if (!isdigit(c) || (max_digits > -1 && counter > max_digits))
        {
            return false;
        }
    }

    return true;
}

bool IsDoubleEqual(double a, double b)
{
    return fabs(a - b) < SMALL_NUMBER;
}

bool IsValidDateTimeFormat(const std::string& dateTimeString)
{
    std::regex datetimePattern(R"(^(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{1,2}):(\d{1,2})(?:\.(\d{1,3}))?$)");
    std::regex timezonePattern(R"(^[+-]\d{4}$)");

    std::string datetimePart = dateTimeString;
    std::string timezonePart;
    auto        pos = dateTimeString.find_last_of("+-");
    if (pos != std::string::npos && pos > dateTimeString.find("T"))
    {
        datetimePart = dateTimeString.substr(0, pos);
        timezonePart = dateTimeString.substr(pos);
    }

    std::smatch m;
    if (!std::regex_match(datetimePart, m, datetimePattern))
    {
        return false;  // Invalid format
    }

    /* 2026-02-02: Skipping this check for now, there's no clear pattern of input and timezone offset isn't used
    if (!timezonePart.empty() && !std::regex_match(timezonePart, timezonePattern))
    {
        LOG_WARN("EnvironmentAction: Missing mandatory timezone offset, assuming +0000");
        return false;
    }
    */

    std::tm           timeStruct = {};
    std::stringstream ss(datetimePart);
    ss >> std::get_time(&timeStruct, "%Y-%m-%dT%H:%M:%S");

    if (ss.fail())
    {
        return false;  // Failed to parse time
    }

    // Check for valid date/time components
    if (timeStruct.tm_year < 0 || timeStruct.tm_year > 20000 || timeStruct.tm_mon < 0 || timeStruct.tm_mon > 11 || timeStruct.tm_mday < 1 ||
        timeStruct.tm_mday > 31 || timeStruct.tm_hour < 0 || timeStruct.tm_hour > 23 || timeStruct.tm_min < 0 || timeStruct.tm_min > 59 ||
        timeStruct.tm_sec < 0 || timeStruct.tm_sec > 59)
    {
        return false;  // Invalid date/time values
    }

    // Basic month day validation
    if (timeStruct.tm_mon == 1 && timeStruct.tm_mday > 29)
        return false;
    if ((timeStruct.tm_mon == 3 || timeStruct.tm_mon == 5 || timeStruct.tm_mon == 8 || timeStruct.tm_mon == 10) && timeStruct.tm_mday > 30)
        return false;

    // Check Leap year for february
    if (timeStruct.tm_mon == 1 && timeStruct.tm_mday == 29)
    {
        int year = timeStruct.tm_year + 1900;
        if (year % 4 != 0)
            return false;
        if (year % 100 == 0 && year % 400 != 0)
            return false;
    }

    // Check milliseconds
    std::string millisecondsStr = (m[7].matched) ? std::string(m[7]) : "0";
    try
    {
        int milliseconds = std::stoi(millisecondsStr);
        if (milliseconds < 0 || milliseconds > 999)
        {
            return false;
        }
    }
    catch (const std::invalid_argument& e)
    {
        LOG_ERROR("IsValidDateTimeFormat: {}", e.what());
        return false;  // Invalid milliseconds
    }

    return true;  // Valid date and time
}

uint32_t GetSecondsSinceMidnight(const std::string& dateTimeString)
{
    std::tm           timeStruct = {};
    std::stringstream ss(dateTimeString);

    ss >> timeStruct.tm_year;
    if (ss.peek() == '-')
        ss.ignore();
    ss >> timeStruct.tm_mon;
    if (ss.peek() == '-')
        ss.ignore();
    ss >> timeStruct.tm_mday;
    if (ss.peek() == 'T')
        ss.ignore();
    ss >> timeStruct.tm_hour;
    if (ss.peek() == ':')
        ss.ignore();
    ss >> timeStruct.tm_min;
    if (ss.peek() == ':')
        ss.ignore();
    ss >> timeStruct.tm_sec;

    // Discard fractional seconds
    if (ss.peek() == '.')
    {
        std::string dummy;
        std::getline(ss, dummy, '+');  // Read until the + in timezone
    }

    // Ignore timezone
    return static_cast<uint32_t>(timeStruct.tm_hour * 3600 + timeStruct.tm_min * 60 + timeStruct.tm_sec);
}

int64_t GetEpochTimeFromString(const std::string& datetime)
{
    std::tm tm = {};

    std::istringstream ss(datetime);
    ss >> std::get_time(&tm, "%Y-%m-%dT%H:%M:%S");

    if (ss.peek() == '.')
    {
        int milliseconds = 0;
        ss.ignore();
        ss >> milliseconds;
    }
    // We're ignoring tz info afterwards, if present

    tm.tm_isdst = -1;  // To be proper, we tell mktime to ignore DST

#if defined(_WIN32)
    std::time_t epoch = _mkgmtime(&tm);
#elif defined(__unix__) || defined(__APPLE__)
    std::time_t epoch = timegm(&tm);
#else
    // fallback if not available
    std::time_t epoch = mktime(&tm);
#endif

    return epoch;
}

double GetSecondsToFactor(int seconds)
{
    // There are 24 * 60 * 60 seconds in a day
    constexpr int secondsInDay = 86400;

    // Normalize the seconds to a range of 0 to 2*pi (one full cycle)
    double normalizedTime = (static_cast<double>(seconds) / secondsInDay) * 2.0 * M_PI;

    // Shift the phase so that the peak (factor 1) is at noon (12 * 3600 seconds)
    // Noon corresponds to the middle of the day, so we shift by pi
    double noonInRadians    = (12.0 * 3600.0 / secondsInDay) * 2.0 * M_PI;
    double phaseShiftedTime = normalizedTime - noonInRadians;

    // Use the cosine function to create the sinusoidal shape.
    // cos(0) = 1, which we want at noon.
    // cos(pi) = -1, which we want at midnight (after shifting).
    // Take the absolute value and then scale and shift to get a range of 0 to 1.
    double factor = 0.5 * (std::cos(phaseShiftedTime) + 1.0);

    return factor;
}

int strtoi(std::string s)
{
    return atoi(s.c_str());
}

double strtod(std::string s)
{
    return atof(s.c_str());
}

void StrCopy(char* dest, const char* src, size_t size, bool terminate)
{
    memcpy(dest, src, size);
    if (terminate && size > 0)
    {
        dest[size - 1] = 0;  // NULL termination
    }
}

std::string GetVersionInfoForLog()
{
    std::string info = "esmini GIT REV: ";
    info.append(esmini_git_rev());
    info.append("\nesmini GIT TAG: ");
    info.append(esmini_git_tag());
    info.append("\nesmini GIT BRANCH: ");
    info.append(esmini_git_branch());
    info.append("\nesmini BUILD VERSION: ");
    info.append(esmini_build_version());
    info.append("\n");
    return info;
}

#if (defined WINVER && WINVER == _WIN32_WINNT_WIN7 || __MINGW32__)

#include <windows.h>
#include <process.h>

__int64 SE_getSystemTime()
{
    return timeGetTime();
}

void SE_sleep(unsigned int msec)
{
    Sleep(msec);
}

#else

__int64 SE_getSystemTimeMilliseconds()
{
    return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
}

__int64 SE_getSystemTimeMicroseconds()
{
    return std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
}

void SE_sleepMilliseconds(unsigned int msec)
{
    std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(msec)));
}

void SE_sleepMicroseconds(unsigned int usec)
{
    std::this_thread::sleep_for(std::chrono::microseconds(static_cast<int>(usec)));
}

#endif

double SE_getSimTimeStep(__int64& time_stamp, double min_time_step, double max_time_step)
{
    double dt;

    __int64 now = SE_getSystemTimeMicroseconds();

    if (time_stamp == 0)
    {
        // First call. Return minimal dt
        dt = min_time_step;
    }
    else
    {
        dt = (now - time_stamp) * 1e-6;  // step size in seconds

        if (dt > max_time_step)  // limit step size
        {
            LOG_DEBUG("Limit stepsize (dt) from {} to {}", dt, max_time_step);
            dt = max_time_step;
        }
        else if (dt < min_time_step)  // avoid CPU rush, sleep for a while
        {
            double nap_duration = min_time_step - dt;
            LOG_DEBUG("dt {:.10f} < minimum {} ms ({}s), take minimal nap", dt, min_time_step * 1e+3, min_time_step);
            SE_sleepMicroseconds(static_cast<unsigned int>(nap_duration * 1e+6));  // sleep microseconds
            now = SE_getSystemTimeMicroseconds();
            dt  = (now - time_stamp) * 1e-6;
        }
    }
    time_stamp = now;

    return dt;
}

std::pair<bool, bool> StrToBool(const std::string& val)
{
    if ("true" == val || "True" == val || "TRUE" == val)
    {
        return {true, true};
    }
    if ("false" == val || "False" == val || "FALSE" == val)
    {
        return {true, false};
    }
    return {false, false};
}

std::vector<std::string> SplitString(const std::string& str, char delimiter)
{
    if (str.empty())
    {
        return {};
    }
    std::vector<std::string> result;
    size_t                   start = 0, end = 0;

    while ((end = str.find(delimiter, start)) != std::string_view::npos)
    {
        result.emplace_back(str.substr(start, end - start));
        start = end + 1;
    }

    // Add the last segment
    result.emplace_back(str.substr(start));

    return result;
}

std::vector<std::string> SplitQuotedString(const std::string& str, char delim)
{
    if (str.empty())
    {
        return {};
    }
    std::vector<std::string> result;
    int                      pos = -1;
    do
    {
        size_t quotePos = str.find_first_of('"', static_cast<size_t>(pos + 1));
        if (quotePos == std::string::npos)
        {
            auto vec = SplitString(str.substr(static_cast<size_t>(pos + 1), str.size()), delim);
            result.insert(result.end(), std::make_move_iterator(vec.begin()), std::make_move_iterator(vec.end()));
            return result;
        }
        size_t nextPos = str.find_first_of('"', quotePos + 1);
        if (nextPos == std::string::npos)
        {
            auto vec = SplitString(str.substr(quotePos + 1, str.size()), delim);
            result.insert(result.end(), std::make_move_iterator(vec.begin()), std::make_move_iterator(vec.end()));
            return result;
        }
        result.emplace_back(str.substr(quotePos + 1, nextPos - quotePos - 1));
        pos = static_cast<int>(nextPos);
    } while (true);
}

std::string DirNameOf(const std::string& fname)
{
    if (fname.empty())
    {
        return "";
    }

    size_t pos = fname.find_last_of("\\/");

    return (std::string::npos == pos) ? "./" : fname.substr(0, pos);
}

std::string FileNameOf(const std::string& fname)
{
    size_t pos = fname.find_last_of("\\/");
    if (pos != std::string::npos)
    {
        return (fname.substr(pos + 1));
    }

    return fname;  // Assume filename with no separator
}

std::string LastDirOfFolderPath(const std::string& path)
{
    size_t pos = path.find_last_of("\\/");
    if (pos != std::string::npos)
    {
        if (pos != path.length() - 1)
        {
            return (path.substr(pos + 1));
        }
        else if (pos != 0)
        {
            std::string tmp = path;
            tmp.pop_back();

            pos = tmp.find_last_of("\\/");

            if (pos != std::string::npos)
            {
                return (tmp.substr(pos + 1));
            }
        }
    }
    else
    {
        return path;  // Assume single name with no separator
    }

    return "";
}

bool IsDirectoryName(const std::string& string)
{
    if (!string.empty() && (string.back() == '/' || string.back() == '\\'))
    {
        return true;
    }

    return false;
}

std::string FileNameExtOf(const std::string& fname)
{
    size_t end_pos = fname.find_last_of(".");
    if (end_pos != std::string::npos)
    {
        return (fname.substr(end_pos, fname.length() - end_pos));
    }
    else
    {
        return ("");
    }
}

std::string FileNameWithoutExtOf(const std::string& fname)
{
    size_t start_pos = fname.find_last_of("\\/");
    if (start_pos != std::string::npos)
    {
        start_pos++;
    }
    else
    {
        start_pos = 0;
    }

    size_t end_pos = fname.find_last_of(".");
    if (end_pos != std::string::npos)
    {
        return (fname.substr(start_pos, end_pos - start_pos));
    }
    else
    {
        return (fname.substr(start_pos));
    }
}

std::string FilePathWithoutExtOf(const std::string& fpath)
{
    size_t end_pos = fpath.find_last_of(".");
    if (end_pos != std::string::npos)
    {
        return (fpath.substr(0, end_pos));
    }
    else
    {
        return fpath;
    }
}

std::string LexicallyNormalizePath(const std::string& path_str)
{
    // This is a Gemini-inspired implementation of fs::path::lexically_normal()
    // We'll use the preferred platform separator for the output,
    // but process all '/' and '\' as delimiters.
    // Standard library path uses '/' internally even on Windows,
    // but for string output, let's default to the common Unix/URL separator.
    const char OUTPUT_SEPARATOR = '/';

    // 1. Convert all '\' to '/' for uniform processing
    std::string temp_path = path_str;
    for (char& c : temp_path)
    {
        if (c == '\\')
        {
            c = '/';
        }
    }

    // Check if the original path was absolute (started with '/' or '\')
    bool is_absolute = !path_str.empty() && temp_path.front() == '/';

    // 2. Tokenize the path string
    std::stringstream        ss(temp_path);
    std::string              segment;
    std::vector<std::string> components;

    // Use '/' to split the path into segments. This handles multiple consecutive separators (e.g., //)
    while (std::getline(ss, segment, OUTPUT_SEPARATOR))
    {
        if (segment.empty() || segment == ".")
        {
            // Ignore empty segments (due to multiple separators like "a//b" or "a\\b")
            // and "." (current directory)
            continue;
        }

        // 3. Handle ".." (Parent directory)
        if (segment == "..")
        {
            // Check if the stack is NOT empty AND the previous component is NOT '..'
            if (!components.empty() && components.back() != "..")
            {
                components.pop_back();  // Remove the last valid component
            }
            else if (!(is_absolute && components.empty()))
            {
                components.push_back(segment);  // Not at root, add segment
            }
        }
        else
        {
            // 4. Keep all other valid components
            components.push_back(segment);
        }
    }

    // 5. Reconstruct the path
    std::string normalized_path;

    if (is_absolute)
    {
        normalized_path += OUTPUT_SEPARATOR;
    }

    // Join the components with the separator
    for (size_t i = 0; i < components.size(); ++i)
    {
        normalized_path += components[i];
        if (i < components.size() - 1)
        {
            normalized_path += OUTPUT_SEPARATOR;
        }
    }

    // Handle edge cases:
    if (normalized_path.empty())
    {
        if (is_absolute)
        {
            return std::string(1, OUTPUT_SEPARATOR);  // e.g., input was "/" or "/./"
        }
        return ".";  // e.g., input was "./" or "a/b/../.."
    }

    return normalized_path;
}

std::string ToLower(const std::string in_str)
{
    std::locale loc;
    std::string out_str = in_str;

    for (size_t i = 0; i < out_str.size(); i++)
    {
        out_str[i] = std::tolower(out_str[i], loc);
    }

    return out_str;
}

std::string ToLower(const char* in_str)
{
    std::locale loc;
    std::string out_str = in_str;

    for (size_t i = 0; i < out_str.size(); i++)
    {
        out_str[i] = std::tolower(out_str[i], loc);
    }

    return out_str;
}

FILE* FileOpen(const char* filename, const char* mode)
{
    FILE* file = nullptr;
#ifdef _WIN32
    int retval = fopen_s(&file, filename, mode);
    if (retval != 0)
    {
        char buffer[256];
        strerror_s(buffer, sizeof(buffer), errno);
        printf("%s\n", buffer);
        return nullptr;
    }
#else
    file = fopen(filename, mode);
#endif

    return file;
}

int GetCrossProduct3D(double x1, double y1, double z1, double x2, double y2, double z2, double& x, double& y, double& z)
{
    x = y1 * z2 - z1 * y2;
    y = z1 * x2 - x1 * z2;
    z = x1 * y2 - y1 * x2;

    return 0;
}

double GetCrossProduct3DMagnitude(double x1, double y1, double z1, double x2, double y2, double z2)
{
    double x, y, z;

    GetCrossProduct3D(x1, y1, z1, x2, y2, z2, x, y, z);

    // Calculate the magnitude of the resulting vector
    return std::sqrt(x * x + y * y + z * z);
}

double GetCrossProduct2D(double x1, double y1, double x2, double y2)
{
    return x1 * y2 - x2 * y1;
}

double GetDotProduct2D(double x1, double y1, double x2, double y2)
{
    return x1 * x2 + y1 * y2;
}

double GetAngleBetweenVectors(double x1, double y1, double x2, double y2)
{
    double dp      = GetDotProduct2D(x1, y1, x2, y2);
    double length1 = GetLengthOfVector2D(x1, y1);
    double length2 = GetLengthOfVector2D(x2, y2);
    if (length1 < SMALL_NUMBER || length2 < SMALL_NUMBER)
    {
        return 0.0;  // Avoid division by zero
    }
    return acos(ABS_LIMIT(dp / (length1 * length2), 1.0));
}

double GetDotProduct3D(double x1, double y1, double z1, double x2, double y2, double z2)
{
    return x1 * x2 + y1 * y2 + z1 * z2;
}

double GetAngleBetweenVectors3D(double x1, double y1, double z1, double x2, double y2, double z2)
{
    double dp      = GetDotProduct3D(x1, y1, z1, x2, y2, z2);
    double length1 = GetLengthOfVector3D(x1, y1, z1);
    double length2 = GetLengthOfVector3D(x2, y2, z2);
    if (length1 < SMALL_NUMBER || length2 < SMALL_NUMBER)
    {
        return 0.0;  // Avoid division by zero
    }
    return acos(ABS_LIMIT(dp / (length1 * length2), 1.0));
}

void NormalizeVec2D(double x, double y, double& xn, double& yn)
{
    double len = sqrt(x * x + y * y);
    if (len < SMALL_NUMBER)
    {
        len = SMALL_NUMBER;
    }
    xn = x / len;
    yn = y / len;
}

void OffsetVec2D(double x0, double y0, double x1, double y1, double offset, double& xo0, double& yo0, double& xo1, double& yo1)
{
    double       angle_line     = atan2(y1 - y0, x1 - x0);
    double       angle_offset   = angle_line + (offset < 0 ? M_PI_2 : -M_PI_2);  // perpendicular to line
    const double line_offset[2] = {fabs(offset) * cos(angle_offset), fabs(offset) * sin(angle_offset)};

    xo0 = x0 + line_offset[0];
    yo0 = y0 + line_offset[1];
    xo1 = x1 + line_offset[0];
    yo1 = y1 + line_offset[1];
}

void ZYZ2EulerAngles(double z0, double y, double z1, double& h, double& p, double& r)
{
    double cx = cos(z0);
    double cy = cos(y);
    double cz = cos(z1);
    double sx = sin(z0);
    double sy = sin(y);
    double sz = sin(z1);

    // Create a rotation matrix Z0 * Y * Z1
    double m[3][3] = {{cx * cy * cz - sx * sz, -cx * cy * sz - sx * cz, cx * sy},
                      {sx * cy * cz + cx * sz, cx * cz - sx * cy * sz, sx * sy},
                      {-sy * cz, sy * sz, cy}};

    // Avoid gimbal lock
    if (fabs(m[0][0]) < SMALL_NUMBER)
        m[0][0] = SIGN(m[0][0]) * SMALL_NUMBER;
    if (fabs(m[2][2]) < SMALL_NUMBER)
        m[2][2] = SIGN(m[2][2]) * SMALL_NUMBER;

    h = atan2(m[1][0], m[0][0]);
    p = atan2(-m[2][0], sqrt(m[2][1] * m[2][1] + m[2][2] * m[2][2]));
    r = atan2(m[2][1], m[2][2]);
}

void R0R12EulerAngles(double h0, double p0, double r0, double h1, double p1, double r1, double& h, double& p, double& r)
{
    // 1. Create two rotation matrices
    // 2. Multiply them
    // 3. Extract yaw. pitch , roll

    double cx = cos(h0);
    double cy = cos(p0);
    double cz = cos(r0);
    double sx = sin(h0);
    double sy = sin(p0);
    double sz = sin(r0);

    const double R0[3][3] = {{cx * cy, cx * sy * sz - sx * cz, sx * sz + cx * sy * cz},
                             {sx * cy, cx * cz + sx * sy * sz, sx * sy * cz - cx * sz},
                             {-sy, cy * sz, cy * cz}};

    cx = cos(h1);
    cy = cos(p1);
    cz = cos(r1);
    sx = sin(h1);
    sy = sin(p1);
    sz = sin(r1);

    const double R1[3][3] = {{cx * cy, cx * sy * sz - sx * cz, sx * sz + cx * sy * cz},
                             {sx * cy, cx * cz + sx * sy * sz, sx * sy * cz - cx * sz},
                             {-sy, cy * sz, cy * cz}};

    // Multiply
    double R2[3][3] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            for (int k = 0; k < 3; k++)
                R2[i][j] += R0[i][k] * R1[k][j];

    // Avoid gimbal lock
    if (fabs(R2[0][0]) < SMALL_NUMBER)
        R2[0][0] = SIGN(R2[0][0]) * SMALL_NUMBER;
    if (fabs(R2[2][2]) < SMALL_NUMBER)
        R2[2][2] = SIGN(R2[2][2]) * SMALL_NUMBER;

    h = GetAngleInInterval2PI(atan2(R2[1][0], R2[0][0]));
    p = GetAngleInInterval2PI(atan2(-R2[2][0], sqrt(R2[2][1] * R2[2][1] + R2[2][2] * R2[2][2])));
    r = GetAngleInInterval2PI(atan2(R2[2][1], R2[2][2]));
}

void CreateRotationMatrix3d(double roll, double pitch, double yaw, double R[3][3])
{
    // Calculate sines and cosines once for efficiency and clarity
    double c_phi   = std::cos(roll);
    double s_phi   = std::sin(roll);
    double c_theta = std::cos(pitch);
    double s_theta = std::sin(pitch);
    double c_psi   = std::cos(yaw);
    double s_psi   = std::sin(yaw);

    // The elements of the combined matrix R = R_x * R_y * R_z

    // Row 0
    R[0][0] = c_theta * c_psi;
    R[0][1] = -c_theta * s_psi;
    R[0][2] = s_theta;

    // Row 1
    R[1][0] = c_phi * s_psi + s_phi * s_theta * c_psi;
    R[1][1] = c_phi * c_psi - s_phi * s_theta * s_psi;
    R[1][2] = -s_phi * c_theta;

    // Row 2
    R[2][0] = s_phi * s_psi - c_phi * s_theta * c_psi;
    R[2][1] = s_phi * c_psi + c_phi * s_theta * s_psi;
    R[2][2] = c_phi * c_theta;

    // Avoid gimbal lock
    if (fabs(R[0][0]) < SMALL_NUMBER)
        R[0][0] = SIGN(R[0][0]) * SMALL_NUMBER;
    if (fabs(R[2][2]) < SMALL_NUMBER)
        R[2][2] = SIGN(R[2][2]) * SMALL_NUMBER;
}

int InvertMatrix3(const double m[3][3], double mi[3][3])
{
    // Augmenting the matrix with the identity matrix
    double augmented_matrix[3][6];

    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            augmented_matrix[i][j]     = m[i][j];
            augmented_matrix[i][j + 3] = (i == j) ? 1.0 : 0.0;
        }
    }

    // Applying Gauss-Jordan elimination
    for (int i = 0; i < 3; i++)
    {
        // Make the diagonal element 1
        double pivot = augmented_matrix[i][i];
        if (pivot == 0)
        {
            LOG_ERROR("Matrix is singular. Inversion not possible.");
            return -1;
        }

        for (int j = 0; j < 2 * 3; j++)
        {
            augmented_matrix[i][j] /= pivot;
        }

        // Make other elements in the column zero
        for (int k = 0; k < 3; k++)
        {
            if (k != i)
            {
                double factor = augmented_matrix[k][i];
                for (int j = 0; j < 2 * 3; j++)
                {
                    augmented_matrix[k][j] -= factor * augmented_matrix[i][j];
                }
            }
        }
    }

    // Extracting the inverse matrix from the augmented matrix
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            mi[i][j] = augmented_matrix[i][j + 3];
        }
    }
    return 0;
}

void CalcRelAnglesFromRoadAndAbsAngles(double  h_road,
                                       double  p_road,
                                       double  r_road,
                                       double  h_abs,
                                       double  p_abs,
                                       double  r_abs,
                                       double& h_rel,
                                       double& p_rel,
                                       double& r_rel)
{
    // 1. Create inverse rotation matrix from road orientation
    // 2. Calculate relative rotation matrix as: Rotation_rel = Rotation_road_inverse * Rotation_abs
    // 3. Extract yaw. pitch , roll

    double R_inv[3][3] = {{}, {}, {}};

    double cx = cos(h_road);
    double cy = cos(p_road);
    double cz = cos(r_road);
    double sx = sin(h_road);
    double sy = sin(p_road);
    double sz = sin(r_road);

    double R[3][3] = {{cx * cy, cx * sy * sz - sx * cz, sx * sz + cx * sy * cz},
                      {sx * cy, cx * cz + sx * sy * sz, sx * sy * cz - cx * sz},
                      {-sy, cy * sz, cy * cz}};

    InvertMatrix3(R, R_inv);

    cx = cos(h_abs);
    cy = cos(p_abs);
    cz = cos(r_abs);
    sx = sin(h_abs);
    sy = sin(p_abs);
    sz = sin(r_abs);

    const double R1[3][3] = {{cx * cy, cx * sy * sz - sx * cz, sx * sz + cx * sy * cz},
                             {sx * cy, cx * cz + sx * sy * sz, sx * sy * cz - cx * sz},
                             {-sy, cy * sz, cy * cz}};

    // Multiply
    double R2[3][3] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            for (int k = 0; k < 3; k++)
                R2[i][j] += R_inv[i][k] * R1[k][j];

    // Avoid gimbal lock
    if (fabs(R2[0][0]) < SMALL_NUMBER)
        R2[0][0] = SIGN(R2[0][0]) * SMALL_NUMBER;
    if (fabs(R2[2][2]) < SMALL_NUMBER)
        R2[2][2] = SIGN(R2[2][2]) * SMALL_NUMBER;

    h_rel = GetAngleInInterval2PI(atan2(R2[1][0], R2[0][0]));
    p_rel = GetAngleInInterval2PI(atan2(-R2[2][0], sqrt(R2[2][1] * R2[2][1] + R2[2][2] * R2[2][2])));
    r_rel = GetAngleInInterval2PI(atan2(R2[2][1], R2[2][2]));
}

void MultMatrixVector3d(const double m[3][3], const double v0[3], double v1[3])
{
    for (int i = 0; i < 3; i++)
    {
        v1[i] = 0.0;
        for (int j = 0; j < 3; j++)
            v1[i] += m[i][j] * v0[j];
    }
}

void MultMatrixMatrix3d(const double m0[3][3], const double m1[3][3], double m_out[3][3])
{
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            m_out[i][j] = 0.0;
            for (int k = 0; k < 3; k++)
            {
                m_out[i][j] += m0[i][k] * m1[k][j];
            }
        }
    }
}

void RotateVec3d(const double h0,
                 const double p0,
                 const double r0,
                 const double x0,
                 const double y0,
                 const double z0,
                 double&      x1,
                 double&      y1,
                 double&      z1)
{
    // 1. Create the rotation matrix
    // 2. Multiply the vector

    double v0[3] = {x0, y0, z0};
    double cx    = cos(h0);
    double cy    = cos(p0);
    double cz    = cos(r0);
    double sx    = sin(h0);
    double sy    = sin(p0);
    double sz    = sin(r0);

    double R[3][3] = {{cx * cy, cx * sy * sz - sx * cz, sx * sz + cx * sy * cz},
                      {sx * cy, cx * cz + sx * sy * sz, sx * sy * cz - cx * sz},
                      {-sy, cy * sz, cy * cz}};

    // Avoid gimbal lock
    if (fabs(R[0][0]) < SMALL_NUMBER)
        R[0][0] = SIGN(R[0][0]) * SMALL_NUMBER;
    if (fabs(R[2][2]) < SMALL_NUMBER)
        R[2][2] = SIGN(R[2][2]) * SMALL_NUMBER;

    double v1[3] = {0.0, 0.0, 0.0};
    MultMatrixVector3d(R, v0, v1);
    x1 = v1[0];
    y1 = v1[1];
    z1 = v1[2];
}

int SE_Env::AddPath(std::string path)
{
    // Check if path already in list
    std::vector<std::string>& paths = SE_Env::Inst().GetOptions().GetOptionValues("path");
    for (size_t i = 0; i < paths.size(); i++)
    {
        if (paths[i] == path)
        {
            return -1;
        }
    }
    SE_Env::Inst().GetOptions().SetOptionValue("path", path, true);

    return 0;
}

int OnRequestShowHelpOrVersion(int argc, char** argv, SE_Options& opt)
{
    int retVal = 0;
    for (int i = 1; i < argc; ++i)
    {
        if (strcmp(argv[i], "--help") == 0 || strcmp(argv[i], "-h") == 0)
        {
            if (opt.GetAppName().empty())
            {
                opt.SetAppName(FileNameWithoutExtOf(argv[0]));
            }
            opt.PrintUsage();
#ifdef _USE_OSG
            if (strstr(argv[0], "dat2csv") == NULL)
            {
                PrintOSGUsage();
            }
#endif  // _USE_OSG
            retVal += 1;
        }
        else if (strcmp(argv[i], "--version") == 0)
        {
            txtLogger.LogVersion();
            retVal += 2;
        }
    }
    return retVal;
}

void PrintOSGUsage()
{
    // Inform about a few OSG options
    printf("Additional OSG graphics options:\n");
    printf("  --clear-color <color>                      Set the background color of the viewer in the form \"r,g,b[,a]\"\n");
    printf("  --screen <num>                             Set the screen to use when multiple screens are present\n");
    printf("  --window <x y w h>                         Set the position x, y and size w, h of the viewer window. -1 -1 -1 -1 for fullscreen.\n");
    printf(
        "  --borderless-window <x y w h>	             Set the position x, y and size w, h of a borderless viewer window. -1 -1 -1 -1 for fullscreen.\n");
    printf("  --SingleThreaded                           Run application and all graphics tasks in one single thread.\n");
    printf("  --lodScale <LOD scalefactor>               Adjust Level Of Detail 1=default >1 decrease fidelity <1 increase fidelity\n");
    printf("\n");
}

std::string GetDefaultPath()
{
#if defined(_WIN32)
    char    path[MAX_PATH];
    HMODULE hModule = nullptr;

    // Get the handle of the current module (Executable/Library)
    if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (LPCTSTR)GetDefaultPath, &hModule))
    {
        LOG_ERROR("Failed to get Executable/Library handle.");
        return "";
    }

    // Get the full path of the Executable/Library
    if (GetModuleFileName(hModule, path, MAX_PATH) == 0)
    {
        LOG_ERROR("Failed to get Executable/Library path.");
        return "";
    }
    LOG_DEBUG("Executable/Library path: {}", path);
    std::string strPath(path);
    return strPath;

#elif defined(__EMSCRIPTEN__)
    // For WASM/Emscripten, return a default path since we don't have dynamic libraries
    LOG_DEBUG("WASM: Using default empty path");
    return "";

#else

    Dl_info dl_info;

    // Use dladdr to retrieve the path of the loaded library
    if (dladdr(reinterpret_cast<void*>(&GetDefaultPath), &dl_info) == 0)
    {
        LOG_ERROR("Failed to get Executable/Library path.");
        return "";
    }
    std::string path(dl_info.dli_fname);
    LOG_DEBUG("Executable/Library path: {}", path);
    return path;

#endif
}

std::string SE_Env::GetModelFilenameById(int model_id)
{
    std::string name;
    if (entity_model_map_.size() == 0)
    {
        entity_model_map_ = ParseModelIds();
    }

    name = entity_model_map_[model_id];

    if (name.empty())
    {
        LOG_ERROR("Failed to lookup 3d model filename for model_id {} in list:", model_id);
        std::map<int, std::string>::iterator it;
        for (it = entity_model_map_.begin(); it != entity_model_map_.end(); ++it)
        {
            LOG_INFO("  {} {}", it->first, it->second);
        }
    }

    return name;
}

SE_Env& SE_Env::Inst()
{
    static SE_Env instance_;
    return instance_;
}

/*
 * Logger for all vehicles contained in the Entities vector.
 *
 * Builds a header based on the number of vehicles then prints data
 * in columnar format, with time running from top to bottom and
 * vehicles running from left to right, starting with the Ego vehicle
 */
CSV_Logger::CSV_Logger() : data_index_(0), callback_(nullptr)
{
}

CSV_Logger::~CSV_Logger()
{
    if (file_.is_open())
    {
        file_.close();
    }

    callback_ = 0;
}

void CSV_Logger::LogEntryHeader(double timestamp)
{
    static char data_entry[max_csv_entry_length];
    snprintf(data_entry, max_csv_entry_length, "%d, %f, ", data_index_, timestamp);
    file_ << data_entry;
}

void CSV_Logger::LogVehicleData(bool        isendline,
                                char const* name,
                                int         id,
                                double      speed,
                                double      wheel_angle,
                                double      wheel_rot,
                                double      bb_x,
                                double      bb_y,
                                double      bb_z,
                                double      bb_length,
                                double      bb_width,
                                double      bb_height,
                                double      posX,
                                double      posY,
                                double      posZ,
                                double      velX,
                                double      velY,
                                double      velZ,
                                double      accX,
                                double      accY,
                                double      accZ,
                                double      distance_road,
                                double      distance_lanem,
                                int         lane_id,
                                double      lane_offset,
                                double      heading,
                                double      heading_rate,
                                double      heading_angle,
                                double      heading_angle_driving_direction,
                                double      pitch,
                                double      curvature,
                                const char* collisions,
                                ...)
{
    static char data_entry[max_csv_entry_length];

    snprintf(data_entry,
             max_csv_entry_length,
             "%s, %d, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %d, %f, %f, %f, %f, %f, %f, %f, %s, ",
             name,
             id,
             speed,
             wheel_angle,
             wheel_rot,
             bb_x,
             bb_y,
             bb_z,
             bb_length,
             bb_width,
             bb_height,
             posX,
             posY,
             posZ,
             velX,
             velY,
             velZ,
             accX,
             accY,
             accZ,
             distance_road,
             distance_lanem,
             lane_id,
             lane_offset,
             heading,
             heading_rate,
             heading_angle,
             heading_angle_driving_direction,
             pitch,
             curvature,
             collisions);

    if (file_.is_open())
    {
        // Add lines horizontally until the endline is reached
        if (isendline == true)
        {
            file_ << data_entry << std::endl;
            file_.flush();
            data_index_++;
        }
        else
        {
            file_ << data_entry;
        }
    }

    if (callback_)
    {
        callback_(data_entry);
    }
}

void CSV_Logger::SetCallback(FuncPtr callback)
{
    callback_ = callback;

    static char message[1024];

    snprintf(message, 1024, "esmini GIT REV: %s", esmini_git_rev());
    callback_(message);
    snprintf(message, 1024, "esmini GIT TAG: %s", esmini_git_tag());
    callback_(message);
    snprintf(message, 1024, "esmini GIT BRANCH: %s", esmini_git_branch());
    callback_(message);
    snprintf(message, 1024, "esmini BUILD VERSION: %s", esmini_build_version());
    callback_(message);
}

// instantiator
// Filename and vehicle number are used for dynamic header creation
void CSV_Logger::Open(std::string scenario_filename, int numvehicles, std::string csv_filename)
{
    if (file_.is_open())
    {
        file_.close();
    }

    file_.open(csv_filename);
    if (file_.fail())
    {
        throw std::iostream::failure(std::string("Cannot open file: ") + csv_filename);
    }

    data_index_ = 0;

    // Standard ESMINI log header, appended with Scenario file name and vehicle count
    static char message[max_csv_entry_length];
    snprintf(message, max_csv_entry_length, "esmini GIT REV: %s", esmini_git_rev());
    file_ << message << std::endl;
    snprintf(message, max_csv_entry_length, "esmini GIT TAG: %s", esmini_git_tag());
    file_ << message << std::endl;
    snprintf(message, max_csv_entry_length, "esmini GIT BRANCH: %s", esmini_git_branch());
    file_ << message << std::endl;
    snprintf(message, max_csv_entry_length, "esmini BUILD VERSION: %s", esmini_build_version());
    file_ << message << std::endl;
    snprintf(message, max_csv_entry_length, "Scenario File Name: %s", scenario_filename.c_str());
    file_ << message << std::endl;
    snprintf(message, max_csv_entry_length, "Number of Vehicles: %d", numvehicles);
    file_ << message << std::endl;

    // Ego vehicle is always present, at least one set of vehicle data values should be stored
    // Index and TimeStamp are included in this first set of columns
    snprintf(message,
             max_csv_entry_length,
             "Index [-], TimeStamp [s], #1 Entity_Name [-], "
             "#1 Entity_ID [-], #1 Current_Speed [m/s], #1 Wheel_Angle [deg], #1 Wheel_Rotation [-], "
             "#1 bb_x [m], #1 bb_y [m], #1 bb_z [m], "
             "#1 bb_length [m], #1 bb_width [m], #1 bb_height [m], "
             "#1 World_Position_X [m], #1 World_Position_Y [m], "
             "#1 World_Position_Z [m], #1 Vel_X [m/s], #1 Vel_Y [m/s], #1 Vel_Z [m/s], "
             "#1 Acc_X [m/s2], #1 Acc_Y [m/s2], #1 Acc_Z [m/s2], "
             "#1 Distance_Travelled_Along_Road_Segment [m], #1 Lateral_Distance_Lanem [m], "
             "#1 lane_id, #1 lane_offset[m], #1 World_Heading_Angle [rad], "
             "#1 Heading_Angle_Rate [rad/s], #1 Relative_Heading_Angle [rad], "
             "#1 Relative_Heading_Angle_Drive_Direction [rad], #1 World_Pitch_Angle [rad], "
             "#1 Road_Curvature [1/m], #1 collision_ids, ");
    file_ << message;

    // Based on number of vehicels in the Entities vector, extend the header accordingly
    for (int i = 2; i <= numvehicles; i++)
    {
        snprintf(message,
                 max_csv_entry_length,
                 "#%d Entity_Name [-], #%d Entity_ID [-],"
                 "#%d Current_Speed [m/s], #%d Wheel_Angle [deg], #%d Wheel_Rotation [-],"
                 "#%d bb_x [m], #%d bb_y [m], #%d bb_z [m], "
                 "#%d bb_length [m], #%d bb_width [m], #%d bb_height [m], "
                 "#%d World_Position_X [m], #%d World_Position_Y [m], #%d World_Position_Z [m], "
                 "#%d Vel_X [m/s], #%d Vel_Y [m/s], #%d Vel_Z [m/s], #%d Acc_X [m/s2], #%d Acc_Y [m/s2], #%d Acc_Z [m/s2], "
                 "#%d Distance_Travelled_Along_Road_Segment [m], #%d Lateral_Distance_Lanem [m], "
                 "#%d lane_id, #%d lane_offset [m], "
                 "#%d World_Heading_Angle [rad], #%d Heading_Angle_Rate [rad/s], #%d Relative_Heading_Angle [rad], "
                 "#%d Relative_Heading_Angle_Drive_Direction [rad], #%d World_Pitch_Angle [rad], "
                 "#%d Road_Curvature [1/m], #%d collision_ids, ",
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i,
                 i);
        file_ << message;
    }
    file_ << std::endl;

    file_.flush();

    callback_ = 0;
}

CSV_Logger& CSV_Logger::Inst()
{
    static CSV_Logger instance_;
    return instance_;
}

SE_Thread::~SE_Thread()
{
    Wait();
}

void SE_Thread::Start(void (*func_ptr)(void*), void* arg)
{
#if (defined WINVER && WINVER == _WIN32_WINNT_WIN7 || __MINGW32__)
    thread_ = (void*)_beginthread(func_ptr, 0, arg);
#else
    thread_ = std::thread(func_ptr, arg);
#endif
}

void SE_Thread::Wait()
{
#if (defined WINVER && WINVER == _WIN32_WINNT_WIN7 || __MINGW32__)
    WaitForSingleObject((HANDLE)thread_, 3000);  // Should never need to wait for more than 3 sec
#else
    if (thread_.joinable())
    {
        thread_.join();
    }
#endif
}

SE_Mutex::SE_Mutex()
{
#if (defined WINVER && WINVER == _WIN32_WINNT_WIN7 || MINGW32)
    mutex_ = (void*)CreateMutex(NULL,   // default security attributes
                                0,      // initially not owned
                                NULL);  // unnamed mutex

    if (mutex_ == NULL)
    {
        LOG_ERROR("CreateMutex error: {}\n", GetLastError());
        mutex_ = 0;
    }
#else

#endif
}

void SE_Mutex::Lock()
{
#if (defined WINVER && WINVER == _WIN32_WINNT_WIN7 || __MINGW32__)
    WaitForSingleObject(mutex_, 1000);  // Should never need to wait for more than 1 sec
#else
    mutex_.lock();
#endif
}

void SE_Mutex::Unlock()
{
#if (defined WINVER && WINVER == _WIN32_WINNT_WIN7 || __MINGW32__)
    ReleaseMutex(mutex_);
#else
    mutex_.unlock();
#endif
}

void SE_Option::Usage() const
{
    std::string showMandatoryStr = isSingleValueOption_ ? "" : "...";
    std::string option_str;

    if (isDefaultArgument_)
    {
        option_str = std::string("[") + std::string(OPT_PREFIX) + opt_str_.c_str() + std::string("]");
    }
    else
    {
        option_str = std::string(OPT_PREFIX) + opt_str_;
    }

    if (!default_value_.empty())
    {
        printf("  %s %s", option_str.c_str(), (opt_arg_ != "") ? ('[' + opt_arg_ + ']' + showMandatoryStr).c_str() : "");
    }
    else
    {
        printf("  %s %s", option_str.c_str(), (opt_arg_ != "") ? ('<' + opt_arg_ + '>' + showMandatoryStr).c_str() : "");
    }

    if (autoApply_)
    {
        printf("  (default if option or value omitted: %s)", default_value_.c_str());
    }
    else if (!default_value_.empty())
    {
        printf("  (default if value omitted: %s)", default_value_.c_str());
    }
    printf("\n      %s\n", opt_desc_.c_str());
}

std::string SE_Option::GetValue(int index) const
{
    if (!(opt_arg_.empty()) && static_cast<unsigned int>(index) < arg_value_.size())
    {
        return arg_value_[static_cast<unsigned int>(index)];
    }
    else
    {
        return "";
    }
}

void SE_Options::AddOption(std::string opt_str,
                           std::string opt_desc,
                           std::string opt_arg,
                           std::string default_value,
                           bool        autoApply,
                           bool        isSingleValueOption,
                           bool        isDefaultArgument)
{
    SE_Option* option = GetOption(opt_str);

    if (option)
    {
        // there can be option already added, maybe the api has done it. which don't have values for str, desc, arg, default value, auto apply
        LOG_DEBUG("Adding info to existing option {}", opt_str);
        option->opt_str_             = opt_str;
        option->opt_desc_            = opt_desc;
        option->opt_arg_             = opt_arg;
        option->default_value_       = default_value;
        option->autoApply_           = autoApply;
        option->isSingleValueOption_ = isSingleValueOption;
        option->isDefaultArgument_   = isDefaultArgument;
    }
    else
    {
        SE_Option opt(opt_str, opt_desc, opt_arg, default_value, autoApply, isSingleValueOption, isDefaultArgument);
        auto      index = esmini_options::ConvertStrKeyToEnum(opt_str);
        if (index != esmini_options::CONFIG_ENUM::CONFIGS_COUNT)
        {
            // option placeholder exists (enum defined)
            LOG_DEBUG("Adding known option {}", opt_str);
            option_[index] = opt;
            option         = &option_[index];
        }
        else
        {
            // option placeholder does not exist (enum not defined), add to the end of the vector
            LOG_ERROR_AND_QUIT("Option {} not availble, add it to config enum", opt_str);
        }
    }

    optionOrder_.push_back(option);

    if (isDefaultArgument)
    {
        default_option_ = optionOrder_.back();
    }
}

void SE_Options::PrintUsage()
{
    printf("\nUsage: %s [options]\n", app_name_.c_str());
    printf("Options: \n");
    for (const auto& option : optionOrder_)
    {
        option->Usage();
    }
    printf("\n");
}

void SE_Options::PrintUnknownArgs(std::string message) const
{
    printf("\n%s\n", message.c_str());
    for (const auto& arg : unknown_args_)
    {
        printf("  %s\n", arg.c_str());
    }
}

bool SE_Options::GetOptionSet(std::string opt)
{
    SE_Option* option = GetOption(opt);

    if (option)
    {
        return option->set_;
    }
    else
    {
        return false;
    }
}

bool SE_Options::GetOptionSetByEnum(esmini_options::CONFIG_ENUM opt)
{
    SE_Option* option = GetOptionByEnum(opt);

    if (option)
    {
        return option->set_;
    }
    else
    {
        return false;
    }
}

bool SE_Options::IsOptionArgumentSet(std::string opt)
{
    if (const auto option = GetOption(opt); option != nullptr)
    {
        return option->set_;
    }

    return false;
}

std::vector<std::string>& SE_Options::GetOptionValues(std::string opt)
{
    SE_Option* option = GetOption(opt);

    if (option == nullptr)
    {
        static std::vector<std::string> empty_list = {};
        return empty_list;
    }

    return option->arg_value_;
}

static constexpr std::array<std::pair<const char*, int>, 10> OSG_ARGS = {{{"--clear-color", 1},
                                                                          {"--screen", 1},
                                                                          {"--window", 4},
                                                                          {"--borderless-window", 0},
                                                                          {"--SingleThreaded", 0},
                                                                          {"--CullDrawThreadPerContext", 0},
                                                                          {"--SingleThreaded", 0},
                                                                          {"--DrawThreadPerContext", 0},
                                                                          {"--CullThreadPerCameraDrawThreadPerContext", 0},
                                                                          {"--lodScale", 1}}};

int SE_Options::ChangeOptionArg(std::string opt, std::string new_value, int index)
{
    SE_Option* option = GetOption(opt);

    if (option == nullptr || index < 0 || static_cast<unsigned int>(index) >= option->arg_value_.size())
    {
        return -1;
    }

    option->arg_value_[static_cast<unsigned int>(index)] = new_value;

    return 0;
}

int SE_Options::SetOptionValue(std::string opt, std::string value, bool add, bool persistent)
{
    SE_Option* option = GetOption(opt);

    if (option == nullptr)
    {
        LOG_ERROR("Specified option {} does not exist", opt);
        return -1;
    }

    if (!option->IsSpecified())
    {
        // option placeholder exists, but it has not added/specified yet. Add preliminary specification.
        AddOption(opt, opt, value);
        option = GetOption(opt);
    }

    if (!value.empty())
    {
        if (!option->opt_arg_.empty())
        {
            // we will not check isSingleValueOption_ in this case, because there is more probability that this function is called
            // from API before the Init is called. In that case isSingleValueOption_ will always be false, which might not be the case
            // for some options
            if (!add)
            {
                option->arg_value_.clear();
            }
            //  we want to insert the value at the beginning of the vector to give last entry priority
            option->arg_value_.insert(option->arg_value_.begin(), value);
        }
        else
        {
            LOG_ERROR("Argument parser error: Missing option {} argument", opt);
            return -1;
        }
    }

    option->persistent_ = persistent;
    option->set_        = true;

    return 0;
}

int SE_Options::UnsetOption(const std::string& opt)
{
    SE_Option* option = GetOption(opt);

    if (option != nullptr)
    {
        option->set_        = false;
        option->persistent_ = false;
        option->arg_value_.clear();
    }
    return 0;
}

int SE_Options::ClearOption(const std::string& opt)
{
    SE_Option* option = GetOption(opt);

    if (option != nullptr)
    {
        option->arg_value_.clear();
    }

    return 0;
}

std::string SE_Options::GetSetOptionsAsStr() const
{
    std::string strAllSetOptions;
    for (const auto& option : option_)
    {
        if (option.set_)
        {
            std::string currentOptionValue;
            if (!option.arg_value_.empty())
            {
                for (auto itr = option.arg_value_.begin(); itr != option.arg_value_.end(); ++itr)
                {
                    currentOptionValue = fmt::format("{} {}", currentOptionValue, *itr);
                }
            }

            strAllSetOptions = fmt::format("{}--{}{} ", strAllSetOptions, option.opt_str_, currentOptionValue);
        }
    }
    return strAllSetOptions;
}

bool SE_Option::IsSpecified() const
{
    return !opt_str_.empty();
}

int SE_Options::ParseArgs(int argc, const char* const argv[])
{
    std::vector<const char*> args = {argv, std::next(argv, argc)};

    app_name_     = FileNameWithoutExtOf(args[0]);
    int returnVal = 0;

    for (size_t i = 0; i < static_cast<unsigned int>(argc); i++)
    {
        originalArgs_.push_back(args[i]);
    }

    for (size_t i = 1; i < static_cast<unsigned int>(argc);)
    {
        std::string arg = args[i];

        if (!(arg.substr(0, strlen(OPT_PREFIX)) == OPT_PREFIX))
        {
            if (default_option_->arg_value_.empty())
            {
                // connsume first unrecognized argument as default option value
                default_option_->arg_value_.push_back(arg);
                default_option_->set_ = true;
            }
            i++;
            continue;
        }

        SE_Option* option = GetOption(&args[i][strlen(OPT_PREFIX)]);  // skip prefix

        if (option)
        {
            option->set_ = true;
            if (option->opt_arg_ != "")
            {
                bool settingSuccess = false;
                do
                {
                    if (i < static_cast<unsigned int>(argc - 1) && strncmp(args[i + 1], "--", 2))
                    {
                        settingSuccess = true;
                        if (option->isSingleValueOption_)
                        {
                            option->arg_value_.clear();
                        }
                        //  we want to insert the value at the beginning of the vector to give last entry priority
                        option->arg_value_.insert(option->arg_value_.begin(), args[i + 1]);
                        i++;
                    }
                    else
                    {
                        break;
                    }
                } while (true);

                if (!settingSuccess && !option->default_value_.empty())
                {
                    settingSuccess = true;
                    option->arg_value_.push_back(option->default_value_);
                }
                if (!settingSuccess)
                {
                    LOG_ERROR("Argument parser error: Missing option {} argument", option->opt_str_);
                    option->set_ = false;
                    returnVal    = -1;
                }
            }
        }
        else
        {
            auto it = std::find_if(std::begin(OSG_ARGS),
                                   std::end(OSG_ARGS),
                                   [&arg](const std::pair<const char*, int> osg_arg) { return osg_arg.first == arg; });
            if (it == std::end(OSG_ARGS))
            {
                unknown_args_.push_back(args[i]);
            }
            else
            {
                i += it->second;  // skip OSG arg and its parameters
            }
        }
        i++;
    }

    ApplyDefaultValues();

    return returnVal;
}

void SE_Options::ApplyDefaultValues()
{
    for (auto& opt : option_)
    {
        if (opt.arg_value_.empty() && !opt.default_value_.empty())
        {
            if ((!opt.autoApply_ && opt.set_) || (opt.autoApply_ && !opt.set_))
            {
                opt.arg_value_.push_back(opt.default_value_);
                opt.set_ = true;
            }
        }
    }
}

SE_Option* SE_Options::GetOption(std::string opt)
{
    auto index = esmini_options::ConvertStrKeyToEnum(opt);
    if (index < esmini_options::CONFIG_ENUM::CONFIGS_COUNT)
    {
        return &option_[index];
    }
    else
    {
        // look at the additional options beyond enums
        for (unsigned int i = esmini_options::CONFIG_ENUM::CONFIGS_COUNT; i < option_.size(); i++)
        {
            if (option_[i].opt_str_ == opt)
            {
                return &option_[i];
            }
        }
    }
    return nullptr;
}

std::string SE_Options::GetOptionValue(std::string opt, unsigned int index)
{
    SE_Option* option = GetOption(opt);

    if (option == nullptr)
    {
        return "";
    }

    return option->GetValue(static_cast<int>(index));
}

SE_Option* SE_Options::GetOptionByEnum(esmini_options::CONFIG_ENUM opt)
{
    if (opt < 0 || opt >= esmini_options::CONFIG_ENUM::CONFIGS_COUNT)
    {
        return nullptr;
    }

    return &option_[opt];
}

void SE_Options::SetAppName(std::string app_name)
{
    if (!app_name_.empty() && app_name != app_name_)
    {
        LOG_WARN("Unexpected option operation: Replacing appname {} with {}", app_name_, app_name);
    }
    app_name_ = app_name;
}

std::string SE_Options::GetAppName() const
{
    return app_name_;
}

std::string SE_Options::GetOptionValueByEnum(esmini_options::CONFIG_ENUM opt)
{
    SE_Option* option = GetOptionByEnum(opt);

    if (opt < 0 || opt >= esmini_options::CONFIG_ENUM::CONFIGS_COUNT)
    {
        return "";
    }

    return option->GetValue();
}

bool SE_Options::IsInOriginalArgs(std::string opt)
{
    if (std::find(originalArgs_.begin(), originalArgs_.end(), opt) != originalArgs_.end())
    {
        return true;
    }

    return false;
}

bool SE_Options::HasUnknownArgs() const
{
    return !unknown_args_.empty();
}

void SE_Options::Reset()
{
    optionOrder_.clear();

    for (auto& option : option_)
    {
        if (!option.persistent_)
        {
            option.set_ = false;
            option.arg_value_.clear();
        }
    }
    originalArgs_.clear();
}

int SE_WritePPM(const char* filename, int width, int height, const unsigned char* data, int pixelSize, int pixelFormat, bool upsidedown)
{
    FILE* file = FileOpen(filename, "wb");

    if (file == nullptr)
    {
        return -1;
    }

    if (pixelSize != 3)
    {
        LOG_ERROR("PPM PixelSize {} not supported yet, only 3", pixelSize);
        return -2;
    }

    if (pixelFormat != static_cast<int>(PixelFormat::BGR) && pixelFormat != static_cast<int>(PixelFormat::RGB))
    {
        LOG_ERROR("PPM PixelFormat {} not supported yet, only 0x{} (RGB) and 0x{} (BGR)", PixelFormat::RGB, PixelFormat::BGR);
        return -3;
    }

    /* Write PPM Header */
    fprintf(file, "P6 %d %d %d\n", width, height, 255); /* width, height, max color value */

    /* Write Image Data */
    if (pixelFormat == static_cast<int>(PixelFormat::RGB))
    {
        if (upsidedown)
        {
            for (int i = 0; i < height; i++)
            {
                for (int j = 0; j < width; j++)
                {
                    // write one line at a time, starting from bottom
                    fwrite(&data[pixelSize * ((height - i - 1) * width + j)], 3, 1, file);
                }
            }
        }
        else
        {
            // Write all RBG pixel values as a whole chunk
            fwrite(data, 3, static_cast<unsigned int>(width * height), file);
        }
    }
    else
    {
        if (upsidedown)
        {
            for (int i = 0; i < height; i++)
            {
                for (int j = 0; j < width; j++)
                {
                    // write one line at a time, starting from bottom
                    const unsigned char* ptr      = &data[pixelSize * ((height - i - 1) * width + j)];
                    const unsigned char  bytes[3] = {(ptr[2]), ptr[1], ptr[0]};
                    fwrite(bytes, 3, 1, file);
                }
            }
        }
        else
        {
            for (int i = 0; i < width * height; i++)
            {
                const unsigned char* ptr      = &data[i * pixelSize];
                const unsigned char  bytes[3] = {(ptr[2]), ptr[1], ptr[0]};
                fwrite(bytes, 3, 1, file);
            }
        }
    }

    fclose(file);

    return 0;
}

int SE_WriteTGA(const char* filename, int width, int height, const unsigned char* data, int pixelSize, int pixelFormat, bool upsidedown)
{
    FILE* file = FileOpen(filename, "wb");

    if (file == nullptr)
    {
        return -1;
    }

    if (pixelSize != 3)
    {
        LOG_ERROR("TGA PixelSize {} not supported yet, only 3", pixelSize);
        return -2;
    }

    if (pixelFormat != static_cast<int>(PixelFormat::BGR) && pixelFormat != static_cast<int>(PixelFormat::RGB))
    {
        LOG_ERROR("TGA PixelFormat 0x{} not supported yet, only 0x{} (RGB) and 0x{} (BGR)", pixelFormat, PixelFormat::RGB, PixelFormat::BGR);
        return -3;
    }

    /* Write TGA Header */
    const uint8_t header[18] = {
        0,
        0,
        2,  // uncompressed RGB
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        static_cast<uint8_t>(width & 0x00FF),
        static_cast<uint8_t>((width & 0xFF00) >> 8),
        static_cast<uint8_t>(height & 0x00FF),
        static_cast<uint8_t>((height & 0xFF00) >> 8),
        static_cast<uint8_t>(pixelSize * 8),             // 24 (BGR)
        static_cast<uint8_t>(upsidedown ? 0 : (1 << 5))  // bit 5 (6:th) controls vertical direction
    };
    fwrite(&header, 18, 1, file);

    /* Write Image Data */
    if (pixelFormat == static_cast<int>(PixelFormat::RGB))
    {
        for (int i = 0; i < width * height; i++)
        {
            const unsigned char* ptr      = &data[i * pixelSize];
            const unsigned char  bytes[3] = {(ptr[2]), ptr[1], ptr[0]};
            fwrite(bytes, 3, 1, file);
        }
    }
    else
    {
        fwrite(data, static_cast<unsigned int>(width * height * pixelSize), 1, file);
    }

    fclose(file);

    return 0;
}

int SE_ReadCSVFile(const char* filename, std::vector<std::vector<std::string>>& content, int skip_lines)
{
    // Cred: https://java2blog.com/read-csv-file-in-cpp/

    std::fstream file(filename, std::ios::in);
    if (file.is_open())
    {
        std::string line;
        for (int i = 0; i < skip_lines; i++)
        {
            if (!getline(file, line))
            {
                LOG_ERROR("Failed to skip {} lines in CSV file {}", skip_lines, filename);
                return -1;
            }
        }
        std::vector<std::string> row;
        std::string              word;
        while (getline(file, line))
        {
            row.clear();

            std::stringstream str(line);

            while (getline(str, word, ','))
                row.push_back(word);
            content.push_back(row);
        }
    }
    else
    {
        LOG_ERROR("Failed to open CSV file {}", filename);
        return -1;
    }

    return 0;
}

const std::string SE_Color::color_strings_[static_cast<size_t>(SE_Color::Color::COUNT)] = {"undefined",    // UNDEFINED
                                                                                           "black",        // BLACK
                                                                                           "blue",         // BLUE
                                                                                           "green",        // GREEN
                                                                                           "orange",       // ORANGE
                                                                                           "red",          // RED
                                                                                           "violet",       // VIOLET
                                                                                           "white",        // WHITE
                                                                                           "yellow",       // YELLOW
                                                                                           "dark_gray",    // DARK_GRAY
                                                                                           "gray",         // GRAY
                                                                                           "light_gray"};  // LIGHT_GRAY

const std::map<std::string, SE_Color::Color> SE_Color::str2enum_ = {{"undefined", Color::UNDEFINED},
                                                                    {"black", Color::BLACK},
                                                                    {"blue", Color::BLUE},
                                                                    {"green", Color::GREEN},
                                                                    {"orange", Color::ORANGE},
                                                                    {"red", Color::RED},
                                                                    {"violet", Color::VIOLET},
                                                                    {"white", Color::WHITE},
                                                                    {"yellow", Color::YELLOW},
                                                                    {"dark_gray", Color::DARK_GRAY},
                                                                    {"gray", Color::GRAY},
                                                                    {"light_gray", Color::LIGHT_GRAY}};

const float SE_Color::rgb_values_[static_cast<size_t>(SE_Color::Color::COUNT)][3] = {
    {0.0f, 0.0f, 0.0f},    // UNDEFINED
    {0.2f, 0.2f, 0.2f},    // BLACK
    {0.25f, 0.38f, 0.7f},  // BLUE
    {0.2f, 0.6f, 0.3f},    // GREEN
    {0.5f, 0.5f, 0.1f},    // ORANGE
    {0.8f, 0.3f, 0.3f},    // RED
    {0.4f, 0.0f, 0.8f},    // VIOLET
    {1.0f, 1.0f, 0.9f},    // WHITE
    {0.85f, 0.8f, 0.2f},   // YELLOW
    {0.5f, 0.5f, 0.5f},    // DARK_GRAY
    {0.7f, 0.7f, 0.7f},    // GRAY
    {0.75f, 0.75f, 0.75f}  // LIGHT_GRAY
};

SE_Color::Color SE_Color::ColorStr2Idx(std::string color_str)
{
    return str2enum_.count(color_str) ? str2enum_.at(color_str) : Color::COUNT;
}

const std::string& SE_Color::ColorIdx2Str(Color color_idx)
{
    if (color_idx == Color::COUNT)
    {
        return color_strings_[static_cast<unsigned int>(Color::UNDEFINED)];
    }

    return color_strings_[static_cast<size_t>(color_idx)];
}

const float (&SE_Color::ColorStr2RBG(std::string color_str))[3]
{
    Color color_enum = ColorStr2Idx(color_str);
    if (color_enum == Color::COUNT)
    {
        LOG_ERROR("Invalid color {} - fallback to undefined", color_str);
        return rgb_values_[static_cast<unsigned int>(Color::UNDEFINED)];
    }
    return rgb_values_[static_cast<size_t>(color_enum)];
}

const float (&SE_Color::Color2RBG(Color color_enum))[3]
{
    if (color_enum == Color::COUNT)
    {
        LOG_ERROR("Invalid color enum {} - fallback to undefined", color_enum);
        return rgb_values_[static_cast<unsigned int>(Color::UNDEFINED)];
    }
    return rgb_values_[static_cast<size_t>(color_enum)];
}
